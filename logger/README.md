# 日志模块设计


## 缓冲区

---
一共存在三块缓冲区， 分别叫 主缓冲区，从缓冲区， 备份缓冲区，
生产者持有前两块缓冲区，消费者持有 备份缓冲区

缓冲区是一个数组，长为 `1024 `，每个元素 `256B` ， 这是我写死的，默认所有日志不会超过 `256` 字节

缓冲区是用 `atomic(memory_order)` 获取唯一元素下标的

## 生产者 和 消费者
所有写日志的线程叫 生产者线程，  后台只有一个  日志线程 叫 消费者线程

## 逻辑
所有生产者   生产日志时 会先获取一把 共享锁，sourction_location 获取文件名和行号，有多个日志函数分别代表不同日志等级
（类似于mysql的元数据锁思想， 多个线程crud不互斥，改表结构才互斥，这里，生产者写日志不互斥，缓冲区交换才互斥），
然后对主缓冲区 无锁队列，使用atomic+memoryorder，来获取缓冲区的唯一编号，保证所有生产者只会获得唯一的数组下标，因为仅仅只是获取一个下标，和其他线程发送互斥的时间是非常低的（因为atomic底层也是用的Lock，compare and swap嘛， except一个值，才交换），后来可能会下标越界了，对于发现下标越界的生成线程，会释放共享锁，然后加一把独占锁，避免后来的线程再次进入，当然这个时候也可能会有几个线程已经进入函数了，不过他们最后都会释放共享锁，然后也尝试等在这把独占锁上，等其他前面的日志线程写完后释放了共享锁， 这些独占锁的候选者会有一个醒来，  并且再次检查是否越界， 未越界说明已经完成交换了，直接递归调用自己和上面的逻辑一样，  而发现越界的那个线程 就是 我们的 交换线程，它负责交换主缓冲区和从缓冲区， 然后notify_one唤醒我们的后台日志线程， 此后主从切换完成， 释放独占锁，后台线程醒来以后会交换从缓存和备用缓存， 日志线程会把写满的那个缓冲区的内容写入日志文件，只是简单的write，并没有fsync。
日志线程写完缓存后又会继续睡在条件变量上，



## 问题
1. 当生产者线程生成过多时，消费者还没有把日志写完，没有等在条件变量上， 生产者线程的notify_one notify了个寂寞， 就会导致丢失一块缓存区的日志内容
2. 
